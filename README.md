# Техническое задание: Серверная часть приложения "Иерархический справочник"

## 1. Общее описание

Данный документ описывает требования к серверной части приложения "Иерархический справочник". Серверная часть представляет собой консольное приложение .NET 8, реализующее RESTful API для управления иерархической структурой данных.

Приложение должно обеспечивать CRUD-операции для узлов справочника, поддерживать версионирование листовых узлов, осуществлять валидацию данных по заданным схемам и соответствовать современным архитектурным принципам.

## 2. Технологический стек и архитектура

### 2.1. Технологический стек
*   **Платформа:** .NET 8, C#
*   **Тип приложения:** Консольное приложение
*   **Веб-сервер:** EmbedIO (для реализации REST HTTP endpoints)
*   **База данных:** SQLite 3
*   **ORM:** Entity Framework Core
*   **Dependency Injection:** `Microsoft.Extensions.DependencyInjection`
*   **Конфигурация:** `appsettings.json`
*   **Логгирование:** Serilog (вывод ошибок и предупреждений в консоль и в файл)

### 2.2. Архитектура
Решение должно быть разделено на проекты по логическим слоям для обеспечения слабой связности и высокой поддерживаемости.

*   **`HierarchicalDirectory.Domain`**: Содержит основные сущности (модели данных для EF Core), интерфейсы репозиториев и сервисов.
*   **`HierarchicalDirectory.Application`**: Содержит бизнес-логику, реализации сервисов, DTO (Data Transfer Objects) и логику валидации.
*   **`HierarchicalDirectory.Infrastructure`**: Содержит реализации интерфейсов из `Domain`, такие как репозитории (с использованием EF Core), конфигурацию `DbContext` для SQLite, настройку Serilog.
*   **`HierarchicalDirectory.Api`**: Консольное приложение, точка входа. Отвечает за настройку и запуск веб-сервера EmbedIO, регистрацию зависимостей (DI), маппинг эндпоинтов и обработку HTTP-запросов.

### 2.3. Принципы разработки
Код должен соответствовать следующим принципам:
*   **SOLID**: Принципы объектно-ориентированного дизайна.
*   **DRY (Don't Repeat Yourself)**: Избегание дублирования кода.
*   **KISS (Keep It Simple, Stupid)**: Простота и ясность реализации.

## 3. Структура и модели данных

### 3.1. Модель данных для хранения (Entity)
Это основная модель, используемая EF Core для работы с базой данных SQLite.

```csharp
public class Category
{
    public string Id { get; set; } // Уникальный идентификатор
    public string Name { get; set; } // Имя узла
    public string? ParentId { get; set; } // Идентификатор родительского узла
    
    public string? Data { get; set; } // Полезные данные в формате JSON-строки
    public string? Schema { get; set; } // Схема валидации в формате JSON-строки
    
    // Поля для версионирования
    public bool IsLatest { get; set; } = true; // Флаг, указывающий на последнюю версию листа
    public DateTime LoadDate { get; set; } // Дата загрузки/создания версии
    
    public virtual Category Parent { get; set; }
    public virtual ICollection<Category> Children { get; set; } = new List<Category>();
}
```

### 3.2. Модель для API (DTO)
Эта модель используется для ответов API, чтобы отделить представление данных от их хранения.

```json
{
  "id": "string",
  "name": "string",
  "parentId": "string | null",
  "data": "any | null",
  "schema": "ValidationSchema | null",
  "isLatest": "boolean",
  "loadDate": "DateTime",
  "children": "Category[]" // Включается опционально
}
```

## 4. Функциональные требования

### 4.1. Бизнес-логика

1.  **Иерархия**:
    *   Каждый узел может иметь одного родителя (кроме корневых).
    *   Листовые элементы — это узлы с пустым массивом `children`.

2.  **Валидация данных**:
    *   При создании/обновлении узла его поле `data` должно валидироваться согласно схеме `schema`.
    *   Если у узла нет своей схемы, используется схема ближайшего родительского узла рекурсивно вверх по иерархии. Если схема не найдена, валидация не производится.

3.  **Уникальность**:
    *   Поле `id` должно быть уникальным в рамках всей системы.
    *   В пределах одного родительского узла имена (`name`) дочерних элементов должны быть уникальны.

4.  **Версионирование листовых узлов**:
    *   Применяется только к листовым узлам. Версии одного листа идентифицируются по уникальному коду в `data` (например, `productCode`) в пределах одного родителя.
    *   При загрузке новой версии листа:
        *   Создается новый узел с `isLatest = true` и текущей датой `loadDate`.
        *   У всех предыдущих версий этого листа поле `isLatest` устанавливается в `false`.

### 4.2. API Endpoints

#### 4.2.1. Получение всей структуры справочника
*   **URL**: `/api/categories`
*   **Метод**: `GET`
*   **Параметры**:
    *   `depth` (int, опционально) - максимальная глубина вложенности.
    *   `search` (string, опционально) - поисковый запрос по имени.
*   **Ответ**:
    *   `200 OK` - массив корневых узлов с иерархией.

#### 4.2.2. Получение конкретного узла по ID
*   **URL**: `/api/categories/{id}`
*   **Метод**: `GET`
*   **Параметры**:
    *   `includeChildren` (boolean, опционально, по умолчанию `false`) - флаг, указывающий, включать ли в ответ все дочерние узлы рекурсивно.
*   **Ответ**:
    *   `200 OK` - объект узла.
    *   `404 Not Found` - узел не найден.

#### 4.2.3. Получение нескольких узлов по списку ID (Новый эндпоинт)
*   **URL**: `/api/categories/batch`
*   **Метод**: `POST` (используется для передачи длинного списка ID в теле запроса)
*   **Тело запроса**:
    ```json
    {
      "ids": ["1.1", "1.2.1", "non-existent-id"],
      "includeChildren": false
    }
    ```
*   **Ответ**:
    *   `200 OK` - массив найденных узлов. Несуществующие ID игнорируются.
    *   `400 Bad Request` - некорректный формат запроса.
*   **Пример ответа**:
    ```json
    [
      {
        "id": "1.1",
        "name": "Смартфоны",
        "parentId": "1",
        "data": { "department": "mobile" },
        "isLatest": true,
        "loadDate": "2025-09-20T10:00:00Z",
        "children": []
      },
      {
        "id": "1.2.1",
        "name": "MacBook",
        "parentId": "1.2",
        "data": { "brand": "Apple" },
        "isLatest": true,
        "loadDate": "2025-09-20T10:05:00Z",
        "children": []
      }
    ]
    ```

#### 4.2.4. Создание нового узла
*   **URL**: `/api/categories`
*   **Метод**: `POST`
*   **Тело запроса**:
    ```json
    {
      "name": "Планшеты",
      "parentId": "1",
      "data": { "department": "mobile" },
      "schema": { "type": "object", "properties": { "department": { "type": "string" } } }
    }
    ```
*   **Ответ**:
    *   `201 Created` - созданный объект узла с присвоенным `id`, `isLatest: true` и `loadDate`.

#### 4.2.5. Обновление узла
*   **URL**: `/api/categories/{id}`
*   **Метод**: `PUT`
*   **Тело запроса**:
    ```json
    {
      "name": "Обновленное название",
      "data": { "department": "mobile_updated" }
    }
    ```
*   **Ответ**:
    *   `200 OK` - обновленный объект узла.
    *   `400 Bad Request` - невалидные данные.
    *   `404 Not Found` - узел не найден.

#### 4.2.6. Удаление узла
*   **URL**: `/api/categories/{id}`
*   **Метод**: `DELETE`
*   **Ответ**:
    *   `204 No Content` - успешно удалено (вместе со всеми дочерними элементами).
    *   `404 Not Found` - узел не найден.

#### 4.2.7. Загрузка новой версии листового узла
*   **URL**: `/api/categories/{parentId}/leaves`
*   **Метод**: `POST`
*   **Тело запроса**: (поле `data` должно содержать уникальный код, например `productCode`)
    ```json
    {
      "name": "iPhone",
      "data": {
        "productCode": "IPH15",
        "brand": "Apple",
        "releaseYear": 2024,
        "storage": "256GB"
      }
    }
    ```
*   **Ответ**:
    *   `201 Created` - созданный объект новой версии листа.
    *   `400 Bad Request` - невалидные данные.
    *   `404 Not Found` - родительский узел (`parentId`) не найден.

#### 4.2.8. Валидация данных узла
*   **URL**: `/api/categories/{id}/validate`
*   **Метод**: `POST`
*   **Тело запроса**:
    ```json
    {
      "data": { "brand": "Apple", "releaseYear": 2023 }
    }
    ```*   **Ответ**:
    *   `200 OK` - при успешной валидации (`{ "valid": true, "errors": [] }`).
    *   `400 Bad Request` - если валидация не пройдена (`{ "valid": false, "errors": [...] }`).

## 5. Технические (нефункциональные) требования

1.  **Конфигурация (`appsettings.json`)**:
    *   Должна содержать строку подключения к SQLite.
    *   Настройки для Serilog (пути к файлам логов, уровни логирования).
    *   URL и порт для запуска сервера EmbedIO.
    ```json
    {
      "EmbedIO": {
        "Url": "http://localhost:9696"
      },
      "ConnectionStrings": {
        "DefaultConnection": "Data Source=directory.db"
      },
      "Serilog": {
        "MinimumLevel": "Information",
        "WriteTo": [
          { "Name": "Console" },
          {
            "Name": "File",
            "Args": {
              "path": "logs/log-.txt",
              "rollingInterval": "Day",
              "restrictedToMinimumLevel": "Warning"
            }
          }
        ]
      }
    }
    ```

2.  **Логгирование**:
    *   Все операции должны логироваться с уровнем `Information`.
    *   Ошибки (статусы 5xx, исключения) и предупреждения (статусы 4xx) должны логироваться в консоль и файл с уровнем `Warning` или `Error`.

3.  **Безопасность**:
    *   Валидация всех входных данных для предотвращения ошибок и уязвимостей.
    *   Архитектура должна позволять добавление аутентификации/авторизации в будущем.

4.  **Обработка ошибок**:
    *   API должен возвращать стандартизированные ответы об ошибках в формате JSON.
    ```json
    {
      "statusCode": 400,
      "message": "Validation failed",
      "details": [ /* ... */ ]
    }
    ```

5.  **Документация**:
    *   Рекомендуется подготовить OpenAPI/Swagger спецификацию для API.
